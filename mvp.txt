Краткие заметки по использованию MVP для антиспам-системы SpamBat

Почему проект назывется SpamBat?
Потому что он противоположен Spam-ботам, которые людей засыпают спамом.
И по настоящему децентрализован. То есть по сути, спам-бот наоборот.
Потому и название такое.
Ещё ассоциацией с летучей мышью, которая пожирает всяких багов.


Предпосылки

Борьба со спамом ведётся уже десятилетия, и радикального успеха не предвидится.
Причина такого положения дел состоит в том, что до текущего момента защита от спама "играет от обороны".
Спамер практически ничем не рискует, рассылая свой спам (или совершая мошеннические звонки),
а накладные расходы на коммуникацию пренебрежимо малы.


Идея проекта

Идея состоит в том, чтобы отправитель нёс финансовую ответственность за свои сообщения.
Ответственность заключается в том, что отправитель прикладывает к своему сообщению
"почтовую марку" - транзакцию в криптовалюте, сжигающую деньги отправителя.

Система передачи сообщения на стороне получателя валидирует марку, и если марки нет,
или она не содержит платежа - просто игнорирует входящее сообщение.

В случае валидной марки, и если сообщение корректное, получатель просто получает сообщение, ничего не делая.
При этом в блокчейн ничего не попадает, и позже марка может быть переиспользована в другом сообщениии.

Если же получатель расцениванивае сообщение как спам, то он публикует транзакцию в блокчейн,
сжигая деньги отправителя, и тем наказывая последнего.

Сжигание монет - ключевой момент системы. Это гарантирует, что у получателя нет иного стимула к публикации
транзакции-марки, кроме как наказать отправителя. Если б скажем транзакция передавала б монеты
куда-нибудь, у получателя появлялся бы ещё и стимул обогатить кого-то.


Архитектура

Архитектура рассмотрена в применении к email-спаму, но может быть адаптирована
для других систем - VOIP-соединений, защите от DOS-атак и тп.

В системе участвует 3 кошелька Emercoin:
 - C которого идут платежи для создания марок W0
 - В котором хранятся UTXO-марки W1
 - Через который получатель валидирует или погашает марку WX.

WX никак не связан с кошельками W0/W1, и может быть даже заблокированным.

Аббревиатура UTXO (Unspent Transaction Output) - непотраченный выход транзакции.
Представляет собою платёжный выход тразакции на фиксированную сумму, которую некто может потратить,
создав ещё одну транзакцию(в том числе и марку).

Рекомендую прикреплять марку к письму (или исходящему VOIP-пакету),
посредством внесения в заголовок строки-расширения:

X-SpamBat: <base64 от hex-a транзакции, лежащей в файле stamps.txt>

Строка должна быть неизменной, чтобы разные мейлеры, которые имплементировали эту систему,
могли корректно отрабатывать марки друг друга.

1. Файл config-lite.php
Должен в php-обёртке  содержать единственную строчку - URL для доступа к кошельку по JSON RPC API.
Cтрока вида:
<?php
$emcCONNECT = "http://username:secret_password@localhost:6662";
?>
Параметры должны соответствовать таковым из emeroin.conf

Далее. Все операции с переименованием кошельков и тп делать только при выключенной ноде!

1. Скрипт W1_generate_addr_pool.php

Предполагается, что этот скрипт работает с кошельком W1.
Запускать его надо, только чтобы создать пул адресов, то есть один раз.

Лучше всего для него создать новый кошелёк.
Нужно переименоват стандартный wallet.dat в что-либо, например wallet.dat-main
После этого - запустить ноду (кошелёк). Он создаст новый пустой wallet.dat.
После - запускаем скрипт W1_generate_addr_pool.php
Он коннектится к ноде, и создаёт пул адресов для будущих транзакци-марок.
Список адресов записывает в addr_pool.txt.
Кол-во адресов задаётся в конфиг-параметре AddrPoolSize
Дефолт 20, можно поставить до 200. Можно поробовать и больше, я не проверял.
Думаю, до 1000 догнать можно.
Это определяет максимальное число выходов в
единственной транзакции, которая будет формировать UTXOs для будущих марок.

Всё, программа отработала, адреса в файл записала.

Пока прекращаем работать с W1, возвращаемся к W0, откуда будем платить за будущие марки.
Для этого останавливаем ноду и переключаем файл кошелька wallet.dat обратно.
Можно сделать два имени, типа:
 - wallet.dat-main      # W0
 - wallet.dat-spambat   # W1
и переключать между ними симлинк.
Скрипт setw.sh предназначен для удобного переключения симлинка на соответствующий файл кошелька на Linux.

2. Скрипт W0_generate_N_UTXO.php
Этот скрипт работает с основным кошельком, где есть баланс.
При старте, в качестве параметра берёт кол-во будущих UTXO для марок.
Потом создаёт единственную транзакцию, которая тратить деньги из кошелька W0,
и создаёт транзакцию, имющую N выходов, направленных в кошелёк W1 (где марки).
N - меньшее из 3х:
 - Число, заданное пользователем
 - Размер фактического пула адресов
 - Кол-во адресов из параметра AddrPoolSize

Скрипт можно запустить несколько раз, он будет создавать по одной транзакции на запуск,
И таким образом - можно напечатать столько UTXO, сколько надо.

Деньги в такой транзакции берутся из W0 и переводятся в W1. Сумма каждого выхода равна цене марки.
Задаётся параметром StampPrice.

После того, как транзакции созданы и приняты в блокчейн, переходим к печати марок.

3. Скрипт W1_generate_stamps.php
Этот скрипт читает файл марок stamps.txt, и на выходе пишет stamps.txt.out
При этом удаляет из входного файла пустые строки и комментарии, а также транзакции-марки, которые были погашены.
Каждая строка файла - 3 колонки:
 - Дата отправки. Не используется скриптом, но полезна для мейлера, который отмечает, когда эта марка была отправлена.
 - Собственно транзакция-марка, которую надо перекодировать в base64 для сокращения размера, и внести результат в заголовок.
 - Цена марки. Не используется системой, но удобна для просмотра, особенно после изменения параметра StampPrice.
После копирования-очистки, программа извлекает из кошелька список UTXO, сгенерированных в фазе [2], и не использованных
в марках, которые только что были скопированы, после чего генерирует новые марки, добавляя в выходной файл.
Марки генерируются на все UTXO из кошелька W1, которых не встретилось в процессе копирования.

Таким образом, получаем файл, каждая строка которого содержит марку. Причём в нём как старые активные марки, так и свеженапечатанные.

4. Скрипт WX_stamp_price.php
Скрипт берёт в качестве параметра hex транзакции-марки, на выходе печатает цену марки.
Если напечатал "0" - значит, марка инвалидна (была уже погашена, или там вообще неверная транзакция).
Верим только маркам, на которые возвращается значение != 0.
И по значению определяем, насколько этой маркой можно наказать отправителя.

5. Скрипт WX_redeem_stamp.php
Скрипт берёт в качестве параметра hex транзакции-марки, и отправляет её в блокчейн, тем погашая. Печатает получившийся TXID.
Здесь невозможно отличить, была ли транзакция погашена ранее, или нет. Ответ всегда валиден, если транзакция синтаксически корректна.
Если надо проверить на валидность - то сначала [4], а потом можно и отправлять.
Замечу, что отправка дубликата - более дешёвая операция, чем проверка валидности. Потому если есть возможность не проверять - проверять не надо.

